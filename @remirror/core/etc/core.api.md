## API Review File for "@remirror/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Component } from 'react';
import { DecorationSet as DecorationSet_2 } from 'prosemirror-view';
import { default } from 'nanoevents';
import { default as default_2 } from 'memoize-one';
import { default as default_3 } from 'object.pick';
import { default as default_4 } from 'object.omit';
import { EditorState as EditorState_2 } from 'prosemirror-state';
import { EditorView as EditorView_2 } from 'prosemirror-view';
import { Fragment as Fragment_2 } from 'prosemirror-model';
import { InputRule as InputRule_2 } from 'prosemirror-inputrules';
import { Interpolation } from '@emotion/core';
import { Interpolation as Interpolation_2 } from 'emotion';
import { Mapping as Mapping_2 } from 'prosemirror-transform';
import { Mark as Mark_2 } from 'prosemirror-model';
import { MarkSpec } from 'prosemirror-model';
import { MarkType as MarkType_2 } from 'prosemirror-model';
import { Node } from 'prosemirror-model';
import { NodeSpec } from 'prosemirror-model';
import { NodeType as NodeType_2 } from 'prosemirror-model';
import { Plugin as Plugin_2 } from 'prosemirror-state';
import { PluginKey as PluginKey_2 } from 'prosemirror-state';
import { ResolvedPos as ResolvedPos_2 } from 'prosemirror-model';
import { Schema } from 'prosemirror-model';
import { Selection as Selection_2 } from 'prosemirror-state';
import { Slice } from 'prosemirror-model';
import { TextSelection } from 'prosemirror-state';
import { Transaction as Transaction_2 } from 'prosemirror-state';

// Warning: (ae-forgotten-export) The symbol "AbsoluteCoordinatesParams" needs to be exported by the entry point index.d.ts
//
// @public
export const absoluteCoordinates: ({ view, element, coords, cursorHeight, }: AbsoluteCoordinatesParams) => {
    left: number;
    right: number;
    top: number;
    bottom: number;
};

// @public (undocumented)
export interface ActionMethods {
    // (undocumented)
    command(attrs?: Attrs): void;
    // (undocumented)
    isActive(attrs?: Attrs): boolean;
    // (undocumented)
    isEnabled(attrs?: Attrs): boolean;
}

// @public
export type AnyConstructor<GType = any> = new (...args: any[]) => GType;

// @public
export type AnyExtension = Extension<any, any, string>;

// @public
export type AnyFunction<GType = any> = (...args: any[]) => GType;

// @public
export function atDocEnd(state: EditorState): boolean;

// @public
export function atDocStart(state: EditorState): boolean;

// @public
export type Attrs = Record<string, string | number | undefined>;

// @public (undocumented)
export interface AttrsParams {
    attrs: Attrs;
}

// @public
export interface BaseExtensionOptions {
    extraAttrs?: ExtraAttrs;
    extraStyles?: Interpolation;
    includeInputRules?: boolean;
    includeKeys?: boolean;
    includePasteRules?: boolean;
    includePlugin?: boolean;
    includeStyles?: boolean;
}

// @public
export const bool: (value: unknown) => boolean;

// @public
export const canInsertNode: (state: EditorState_2<import("prosemirror-model").Schema<string, string>>, type: NodeType_2<any>) => boolean;

// @public
export const capitalize: (str: string) => string;

// @public
export const Cast: <GType = any>(arg: any) => GType;

// @public
export const cleanupOS: (os: string, pattern?: string | undefined, label?: string | undefined) => string;

// @public
export const clone: <GObject extends {}>(value: GObject) => GObject;

// @public
export const cloneTransaction: (tr: import("prosemirror-state").Transaction<import("prosemirror-model").Schema<string, string>>) => import("prosemirror-state").Transaction<import("prosemirror-model").Schema<string, string>>;

// @public
export const closestElement: (domNode: Node | null | undefined, selector: string) => HTMLElement | null;

// @public
export type CommandFunction = (state: EditorState, dispatch: DispatchFunction | undefined, view: EditorView) => boolean;

// @public (undocumented)
export interface CommandParams extends ExtensionManagerParams {
    // (undocumented)
    isEditable: () => boolean;
    // (undocumented)
    view: EditorView;
}

// @public (undocumented)
export interface CompareStateParams {
    newState: EditorState;
    prevState: EditorState;
}

// Warning: (ae-forgotten-export) The symbol "CreateDocumentNodeParams" needs to be exported by the entry point index.d.ts
//
// @public
export const createDocumentNode: ({ content, schema, doc }: CreateDocumentNodeParams) => Node<import("prosemirror-model").Schema<string, string>> | null;

// Warning: (ae-forgotten-export) The symbol "CreateFlexibleFunctionMapParams" needs to be exported by the entry point index.d.ts
// Warning: (ae-internal-missing-underscore) The name createFlexibleFunctionMap should be prefixed with an underscore because the declaration is marked as "@internal"
//
// @internal
export const createFlexibleFunctionMap: <GKey extends "active" | "enabled" | "type" | "name" | "options" | "pluginKey" | "defaultOptions" | "requiredExtensions" | "styles" | "commands" | "pasteRules" | "inputRules" | "keys" | "plugin", GMappedFunc extends AnyFunction<any>, GFunc extends AnyFunction<any>>({ key, checkUniqueness, getItemParams, methodFactory, arrayTransformer, ctx, }: CreateFlexibleFunctionMapParams<GKey, GMappedFunc, GFunc>) => (params: CommandParams) => Record<string, GMappedFunc>;

// @public (undocumented)
export type DecorationSet = DecorationSet_2<EditorSchema>;

// @public
export type DispatchFunction = (tr: Transaction) => void;

// @public (undocumented)
export class Doc extends NodeExtension {
    // (undocumented)
    readonly name: "doc";
    // (undocumented)
    readonly schema: NodeExtensionSpec;
}

// Warning: (ae-forgotten-export) The symbol "DOMOutputSpecPos1" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DOMOutputSpecPosX" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type DOMOutputSpec = string | [string, 0] | [string, DOMOutputSpecPos1?, DOMOutputSpecPosX?, DOMOutputSpecPosX?, DOMOutputSpecPosX?, DOMOutputSpecPosX?, DOMOutputSpecPosX?, DOMOutputSpecPosX?, DOMOutputSpecPosX?, DOMOutputSpecPosX?, DOMOutputSpecPosX?];

// @public
export const EDITOR_CLASS_NAME = "remirror-editor";

// @public
export const EDITOR_CLASS_SELECTOR: string;

// @public (undocumented)
export type EditorSchema<GNodes extends string = string, GMarks extends string = string> = Schema<GNodes, GMarks>;

// @public (undocumented)
export type EditorState<GSchema extends EditorSchema = EditorSchema> = EditorState_2<GSchema>;

// @public (undocumented)
export interface EditorStateParams {
    state: EditorState;
}

// @public (undocumented)
export type EditorView = EditorView_2<EditorSchema>;

// @public (undocumented)
export interface EditorViewParams {
    view: EditorView;
}

// @public (undocumented)
export interface ElementParams {
    element: HTMLElement;
}

// @public (undocumented)
export type ElementUnion = Value<HTMLElementTagNameMap>;

// @public
export const EMPTY_OBJECT_NODE: {
    type: string;
    content: {
        type: string;
    }[];
};

// @public
export function endPositionOfParent(pmPosition: ResolvedPos): number;

// @public
export const enhancedNodeInputRule: InputRuleCreator;

// @public
export const environment: {
    readonly isBrowser: boolean;
    readonly isJSDOM: boolean;
    readonly isNode: boolean;
    readonly isMac: boolean;
};

// @public
export const equalNodeType: (type: import("prosemirror-model").NodeType<import("prosemirror-model").Schema<string, string>> | import("prosemirror-model").NodeType<import("prosemirror-model").Schema<string, string>>[], node: import("prosemirror-model").Node<import("prosemirror-model").Schema<string, string>>) => boolean;

// @public
export abstract class Extension<GOptions extends BaseExtensionOptions = BaseExtensionOptions, GType = never, GCommands extends string = string> {
    constructor(options?: GOptions);
    readonly defaultOptions: Partial<GOptions>;
    protected extraAttrs(): Record<string, {
        default?: unknown;
    }>;
    protected init(): void;
    abstract readonly name: string;
    readonly options: Required<GOptions>;
    readonly pluginKey: PluginKey_2;
    readonly type: ExtensionType;
}

// @public (undocumented)
export interface Extension<GOptions extends BaseExtensionOptions = BaseExtensionOptions, GType = never, GCommands extends string = string> {
    active?(params: ExtensionManagerParams): FlexibleConfig<ExtensionBooleanFunction, GCommands>;
    commands?(params: SchemaTypeParams<GType>): FlexibleConfig<ExtensionCommandFunction, GCommands>;
    enabled?(params: ExtensionManagerParams): FlexibleConfig<ExtensionBooleanFunction, GCommands>;
    inputRules?(params: SchemaTypeParams<GType>): InputRule_2[];
    keys?(params: SchemaTypeParams<GType>): KeyboardBindings;
    pasteRules?(params: SchemaTypeParams<GType>): ProsemirrorPlugin[];
    plugin?(params: SchemaTypeParams<GType>): ProsemirrorPlugin;
    // @alpha
    readonly requiredExtensions?: RequiredExtension[];
    styles?(params: ExtensionManagerParams): Interpolation_2;
}

// @public (undocumented)
export type ExtensionBooleanFunction = (attrs?: Attrs) => boolean;

// @public (undocumented)
export type ExtensionCommandFunction = (attrs?: Attrs) => CommandFunction;

// @public
export interface ExtensionConstructor<GOptions extends BaseExtensionOptions, GExtension extends Extension<GOptions, any, string>> {
    // (undocumented)
    new (options?: GOptions): GExtension;
}

// @public (undocumented)
export class ExtensionManager {
    constructor(extensionMapValues: ExtensionMapValue[]);
    actions(params: CommandParams): RemirrorActions;
    static create(extensions: ExtensionMapValue[]): ExtensionManager;
    createSchema(): EditorSchema;
    // Warning: (ae-forgotten-export) The symbol "ExtensionManagerData" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly data: ExtensionManagerData;
    // (undocumented)
    readonly extensions: AnyExtension[];
    // (undocumented)
    getEditorState: () => EditorState_2;
    getPluginState<GState>(name: string): GState;
    // (undocumented)
    getPortalContainer: () => NodeViewPortalContainer;
    // Warning: (ae-forgotten-export) The symbol "ExtensionManagerInitParams" needs to be exported by the entry point index.d.ts
    init({ getEditorState, getPortalContainer }: ExtensionManagerInitParams): this;
    // (undocumented)
    initView(view: EditorView): void;
    inputRules(params: ExtensionManagerParams): import("prosemirror-state").Plugin<any, any>;
    isEqual(otherManager: unknown): boolean;
    keymaps(params: ExtensionManagerParams): import("prosemirror-state").Plugin<any, any>[];
    readonly marks: Record<string, MarkExtensionSpec>;
    readonly nodes: Record<string, NodeExtensionSpec>;
    pasteRules(params: ExtensionManagerParams): ProsemirrorPlugin[];
    readonly pluginKeys: Record<string, PluginKey_2<any, any>>;
    plugins(params: ExtensionManagerParams): import("prosemirror-state").Plugin<any, Schema<string, string>>[];
    // (undocumented)
    styles(params: ExtensionManagerParams): Interpolation_2[];
}

// @public (undocumented)
export interface ExtensionManagerParams extends SchemaParams {
    getEditorState: () => EditorState;
    getPortalContainer: () => NodeViewPortalContainer;
}

// @public
export interface ExtensionMapValue {
    extension: AnyExtension;
    priority: number;
}

// @public
export type ExtensionOptions<GExtension extends Extension> = GExtension extends Extension<infer P, any> ? P : never;

// Warning: (ae-forgotten-export) The symbol "ExtensionMethodProperties" needs to be exported by the entry point index.d.ts
//
// @public
export const extensionPropertyMapper: <GExt extends Extension<any, any, string>, GExtMethodProp extends ExtensionMethodProperties>(property: GExtMethodProp, params: ExtensionManagerParams) => (extension: GExt) => GExt[GExtMethodProp] extends AnyFunction<any> ? ReturnType<GExt[GExtMethodProp]> : {};

// @public
export enum ExtensionType {
    // (undocumented)
    EXTENSION = "extension",
    // (undocumented)
    MARK = "mark",
    // (undocumented)
    NODE = "node"
}

// @public
export type ExtraAttrs = Array<string | [string, string]>;

// @public
export const findDOMRefAtPos: (position: number, view: import("../../../../support/types/prosemirror-view").EditorView<import("prosemirror-model").Schema<string, string>>) => HTMLElement;

// @public
export const findMatches: (text: string, regexp: RegExp) => RegExpExecArray[];

// Warning: (ae-forgotten-export) The symbol "FindParentNode" needs to be exported by the entry point index.d.ts
//
// @public
export const findParentNode: (predicate: (node: import("prosemirror-model").Node<import("prosemirror-model").Schema<string, string>>) => boolean) => (selection: Selection_2<import("prosemirror-model").Schema<string, string>>) => FindParentNode | undefined;

// @public
export const findParentNodeOfType: (type: import("prosemirror-model").NodeType<import("prosemirror-model").Schema<string, string>> | import("prosemirror-model").NodeType<import("prosemirror-model").Schema<string, string>>[]) => (selection: Selection_2<import("prosemirror-model").Schema<string, string>>) => FindParentNode | undefined;

// @public
export const findPositionOfNodeBefore: (selection: Selection_2<import("prosemirror-model").Schema<string, string>>) => number | undefined;

// @public (undocumented)
export interface FixedCoordsParams {
    coords: Position;
}

// @public (undocumented)
export type FlexibleConfig<GFunc extends AnyFunction, GNames extends string = string> = GFunc | GFunc[] | Record<GNames, GFunc | GFunc[]>;

// @public
export const format: (str: string) => string;

// @public (undocumented)
export type Fragment = Fragment_2<EditorSchema>;

// Warning: (ae-forgotten-export) The symbol "FromHTMLParams" needs to be exported by the entry point index.d.ts
//
// @public
export const fromHTML: ({ content, schema, doc }: FromHTMLParams) => Node<import("prosemirror-model").Schema<string, string>>;

// @public (undocumented)
export interface FromToParams {
    from: number;
    to: number;
}

// @public (undocumented)
export type GetAttrs = Attrs | ((p: string[] | string) => Attrs | null | undefined);

// @public
export function getCursor(selection: Selection): ResolvedPos | null | undefined;

// @public
export const getLineHeight: ({ element }: ElementParams) => number;

// @public
export const getMarkAttrs: (state: EditorState_2<import("prosemirror-model").Schema<string, string>>, type: MarkType_2<any>) => {
    [key: string]: any;
};

// @public
export const getMarkRange: (pmPosition?: import("prosemirror-model").ResolvedPos<import("prosemirror-model").Schema<string, string>> | null, type?: MarkType_2<any> | null | undefined) => false | FromToParams;

// @public
export const getMatchString: (match: string | string[], index?: number) => string;

// @public
export const getNearestNonTextNode: (domNode: Node) => HTMLElement;

// Warning: (ae-forgotten-export) The symbol "GetOffsetParentParams" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const getOffsetParent: ({ view, element }: GetOffsetParentParams) => HTMLElement;

// @public
export const getPluginMeta: <GMeta>(key: string | Plugin_2<any, any> | import("prosemirror-state").PluginKey<any, import("prosemirror-model").Schema<string, string>>, tr: import("prosemirror-state").Transaction<import("prosemirror-model").Schema<string, string>>) => GMeta;

// @public
export const getPluginState: <GState>(plugin: Plugin_2<any, any> | import("prosemirror-state").PluginKey<any, import("prosemirror-model").Schema<string, string>>, state: EditorState_2<import("prosemirror-model").Schema<string, string>>) => GState;

// @public
export const getSelectedGroup: (state: EditorState_2<import("prosemirror-model").Schema<string, string>>, exclude: RegExp) => false | FromToParams;

// @public
export const getSelectedWord: (state: EditorState_2<import("prosemirror-model").Schema<string, string>>) => false | FromToParams;

// @public
export const getTextContentFromSlice: (slice: Slice<any>) => string;

// @public
export const hasExtensionProperty: <GExt extends Extension<any, any, string>, GKey extends keyof GExt>(property: GKey) => (extension: GExt) => extension is GExt & Pick<Required<GExt>, GKey>;

// @public (undocumented)
export interface HasExtensions {
    extensions: AnyExtension[];
}

// Warning: (ae-internal-missing-underscore) The name ignoreFunctions should be prefixed with an underscore because the declaration is marked as "@internal"
//
// @internal
export const ignoreFunctions: (obj: Record<string, unknown>) => Record<string, unknown>;

// @public (undocumented)
export type InputRule = InputRule_2<EditorSchema>;

// @public (undocumented)
export type InputRuleCreator = (regexp: RegExp, nodeType: NodeType_2, getAttrs?: GetAttrs, joinPredicate?: (p1: string[], p2: Node) => boolean) => InputRule;

// @public
export const isAndroidOS: () => boolean;

// @public
export const isArray: (arg: any) => arg is any[];

// @public
export const isBoolean: (value: unknown) => value is boolean;

// @public @deprecated
export const isClass: (value: unknown) => value is AnyConstructor<any>;

// @public
export const isDate: (value: unknown) => value is Date;

// @public
export const isDocNode: (node: Node<import("prosemirror-model").Schema<string, string>> | null | undefined, schema?: import("prosemirror-model").Schema<string, string> | undefined) => boolean;

// @public
export const isDocNodeEmpty: (node: Node<import("prosemirror-model").Schema<string, string>>) => boolean;

// @public
export const isDOMNode: (domNode: unknown) => domNode is Node;

// @public
export const isEditorState: (value: unknown) => value is EditorState_2<import("prosemirror-model").Schema<string, string>>;

// @public
export const isElementDOMNode: (domNode: unknown) => domNode is HTMLElement;

// @public
export const isEmptyArray: (value: unknown) => value is never[];

// @public
export const isEmptyObject: (value: unknown) => value is {
    [key: string]: never;
};

// @public
export const isEmptyParagraphNode: (node: Node<import("prosemirror-model").Schema<string, string>> | null | undefined) => boolean;

// @public
export const isEqual: (a: any, b: any) => boolean;

// @public
export const isError: (value: unknown) => value is Error;

// @public
export const isExtensionManager: (value: unknown) => value is ExtensionManager;

// @public
export const isFunction: (value: unknown) => value is AnyFunction<any>;

// @public
export const isInteger: (value: unknown) => value is number;

// @public
export const isMap: (value: unknown) => value is Map<unknown, unknown>;

// @public
export const isMarkExtension: (extension: unknown) => extension is MarkExtension<any>;

// Warning: (ae-forgotten-export) The symbol "IsNameUniqueParams" needs to be exported by the entry point index.d.ts
//
// @public
export const isNameUnique: ({ name, set, shouldThrow, type }: IsNameUniqueParams) => void;

// @public
export const isNativePromise: (value: unknown) => value is Promise<unknown>;

// @public
export const isNodeExtension: (extension: unknown) => extension is NodeExtension<any>;

// @public
export const isNull: (value: unknown) => value is null;

// @public
export const isNullOrUndefined: (value: unknown) => value is null | undefined;

// @public
export const isNumber: (value: unknown) => value is number;

// @public
export const isObject: (value: unknown) => value is object;

// @public
export const isObjectNode: (value: unknown) => value is ObjectNode;

// @public
export const isPlainExtension: (extension: unknown) => extension is Extension<any, never, string>;

// @public
export const isPlainObject: (value: unknown) => value is PlainObject;

// @public
export const isPromise: (value: unknown) => value is Promise<unknown>;

// @public
export const isProsemirrorNode: (value: unknown) => value is Node<import("prosemirror-model").Schema<string, string>>;

// @public
export const isRegExp: (value: unknown) => value is RegExp;

// @public
export const isSafeInteger: (value: unknown) => value is number;

// @public
export const isSelection: (value: unknown) => value is Selection_2<import("prosemirror-model").Schema<string, string>>;

// @public
export const isSet: (value: unknown) => value is Set<unknown>;

// @public
export const isString: (value: unknown) => value is string;

// @public
export const isSymbol: (value: unknown) => value is symbol;

// @public
export const isTextDOMNode: (domNode: unknown) => domNode is Text;

// @public
export const isTextSelection: (value: unknown) => value is TextSelection<import("prosemirror-model").Schema<string, string>>;

// @public
export const isUndefined: (value: unknown) => value is undefined;

// @public (undocumented)
export type Key<GRecord> = keyof GRecord;

// @public
export type KeyboardBindings = Record<string, CommandFunction>;

// @public
export const LEAF_NODE_REPLACING_CHARACTER = "\uFFFC";

// @public
export type Literal = string | number | boolean | undefined | null | void | {};

// @public
export type MakeNullable<GType extends {}, GKeys extends keyof GType> = Omit<GType, GKeys> & {
    [P in GKeys]: GType[P] | null;
};

// @public
export type MakeOptional<GType extends {}, GKeys extends keyof GType> = Omit<GType, GKeys> & {
    [P in GKeys]+?: GType[P];
};

// @public
export type MakeReadonly<GType extends {}, GKeys extends keyof GType> = Omit<GType, GKeys> & {
    +readonly [P in GKeys]: GType[P];
};

// @public
export type MakeRequired<GType extends {}, GKeys extends keyof GType> = Omit<GType, GKeys> & {
    [P in GKeys]-?: GType[P];
};

// @public (undocumented)
export type Mapping = Mapping_2;

// @public (undocumented)
export type Mark = Mark_2<EditorSchema>;

// @public
export const markActive: (state: EditorState_2<import("prosemirror-model").Schema<string, string>>, type: MarkType_2<any>) => boolean;

// @public (undocumented)
export abstract class MarkExtension<GOptions extends MarkExtensionOptions = MarkExtensionOptions> extends Extension<GOptions, MarkType_2<EditorSchema>> {
    // (undocumented)
    active({ getEditorState, schema, }: ExtensionManagerParams): FlexibleConfig<ExtensionBooleanFunction>;
    // (undocumented)
    abstract readonly schema: MarkExtensionSpec;
    // (undocumented)
    readonly type: ExtensionType.MARK;
}

// @public (undocumented)
export type MarkExtensionOptions = BaseExtensionOptions;

// @public (undocumented)
export type MarkExtensionSpec = Omit<MarkSpec, 'toDOM'> & {
    toDOM?: ((mark: Mark, inline: boolean) => DOMOutputSpec) | null;
};

// @public
export enum MarkGroup {
    // (undocumented)
    ALIGNMENT = "alignment",
    // (undocumented)
    COLOR = "color",
    // (undocumented)
    FONT_STYLE = "fontStyle",
    // (undocumented)
    INDENTATION = "indentation",
    // (undocumented)
    LINK = "link",
    // (undocumented)
    SEARCH_QUERY = "searchQuery"
}

// @public
export const markInputRule: (regex: RegExp, type: MarkType_2<any>, getAttrs?: Record<string, string | number | undefined> | ((attrs: string[]) => Record<string, string | number | undefined>) | undefined) => InputRule_2<any>;

// @public
export const markPasteRule: PluginCreator;

// @public (undocumented)
export type MarkType = MarkType_2<EditorSchema>;

// @public (undocumented)
export interface MarkTypeParams {
    type: MarkType;
}

// @public
export const memoize: typeof default_2;

// @public (undocumented)
export interface MountedPortal {
    // (undocumented)
    children: () => JSX.Element;
    // (undocumented)
    hasReactContext: boolean;
    // (undocumented)
    key: string;
}

// Warning: (ae-forgotten-export) The symbol "NodeActiveParams" needs to be exported by the entry point index.d.ts
//
// @public
export const nodeActive: ({ state, type, attrs }: NodeActiveParams) => boolean;

// @public
export abstract class NodeExtension<GOptions extends NodeExtensionOptions = NodeExtensionOptions> extends Extension<GOptions, NodeType_2<EditorSchema>> {
    // (undocumented)
    active({ getEditorState, type }: SchemaNodeTypeParams): FlexibleConfig<ExtensionBooleanFunction>;
    // (undocumented)
    abstract readonly schema: NodeExtensionSpec;
    readonly type: ExtensionType.NODE;
}

// @public (undocumented)
export type NodeExtensionOptions = BaseExtensionOptions;

// @public (undocumented)
export type NodeExtensionSpec = Omit<NodeSpec, 'toDOM'> & {
    toDOM?: ((node: ProsemirrorNode) => DOMOutputSpec) | null;
};

// @public
export const nodeInputRule: InputRuleCreator;

// @public
export type NodeMatch = string | ((name: string, node: ProsemirrorNode) => boolean) | RegexTuple;

// @public
export const nodeNameMatchesList: (node: Node<import("prosemirror-model").Schema<string, string>> | null | undefined, nodeMatches: NodeMatch[]) => node is Node<import("prosemirror-model").Schema<string, string>>;

// @public (undocumented)
export type NodeType = NodeType_2<EditorSchema>;

// @public (undocumented)
export interface NodeTypeParams {
    type: NodeType;
}

// @public (undocumented)
export interface NodeViewPortalComponentProps {
    // (undocumented)
    nodeViewPortalContainer: NodeViewPortalContainer;
}

// @public (undocumented)
export class NodeViewPortalContainer {
    // (undocumented)
    context: Component<NodeViewPortalComponentProps>;
    // Warning: (ae-forgotten-export) The symbol "Events" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    events: default<Events>;
    // (undocumented)
    forceUpdate(): void;
    // (undocumented)
    on: (callback: (map: Map<HTMLElement, MountedPortal>) => void) => () => void;
    // (undocumented)
    portals: Map<HTMLElement, MountedPortal>;
    // (undocumented)
    remove(container: HTMLElement): void;
    // (undocumented)
    render(children: () => JSX.Element, container: HTMLElement, hasReactContext?: boolean): void;
    // (undocumented)
    setContext: (context: Component<NodeViewPortalComponentProps, {}, any>) => void;
    }

// @public
export const NULL_CHARACTER = "\0";

// @public
export interface ObjectMark {
    // (undocumented)
    attrs?: Record<string, string | null>;
    // (undocumented)
    type: string;
}

// @public
export interface ObjectNode {
    // (undocumented)
    attrs?: Record<string, Literal | object>;
    // (undocumented)
    content?: ObjectNode[];
    // (undocumented)
    marks?: Array<ObjectMark | string>;
    // (undocumented)
    text?: string;
    // (undocumented)
    type: string;
}

// @public
export type Omit<GType, GKeys extends keyof GType> = Pick<GType, Exclude<keyof GType, GKeys>>;

// @public
export const omit: typeof default_4;

// @public (undocumented)
export class Paragraph extends NodeExtension {
    // (undocumented)
    commands({ type }: SchemaNodeTypeParams): () => (state: import("prosemirror-state").EditorState<import("prosemirror-model").Schema<string, string>>, dispatch?: ((tr: import("prosemirror-state").Transaction<import("prosemirror-model").Schema<string, string>>) => void) | undefined) => boolean;
    // (undocumented)
    readonly name: "paragraph";
    // (undocumented)
    readonly schema: NodeExtensionSpec;
}

// @public
export const pick: typeof default_3;

// @public
export interface PlainObject {
    // (undocumented)
    [key: string]: unknown;
}

// @public (undocumented)
export type Plugin<GPluginState = any> = Plugin_2<GPluginState, EditorSchema>;

// @public (undocumented)
export type PluginCreator = <GType extends NodeType_2 | MarkType_2>(regexp: RegExp, nodeType: GType, getAttrs?: GetAttrs, joinPredicate?: (p1: string[], p2: Node) => boolean) => Plugin_2;

// @public (undocumented)
export type PluginKey<GPluginState = any> = PluginKey_2<GPluginState, EditorSchema>;

// @public (undocumented)
export type PortalList = ReadonlyArray<[HTMLElement, MountedPortal]>;

// @public (undocumented)
export type PortalMap = Map<HTMLElement, MountedPortal>;

// @public
export interface Position {
    // (undocumented)
    bottom: number;
    // (undocumented)
    left: number;
    // (undocumented)
    right: number;
    // (undocumented)
    top: number;
}

// @public (undocumented)
export interface PositionParams {
    position: Position;
}

// @public
export type Predicate<A> = (u: unknown) => u is A;

// @public (undocumented)
export type ProsemirrorNode = Node<EditorSchema>;

// @public (undocumented)
export type ProsemirrorPlugin<GPluginState = any> = Plugin_2<GPluginState, EditorSchema>;

// @public
export function randomFloat(min: number, max?: number): number;

// @public
export function randomInt(min: number, max?: number): number;

// @public
export type RegexTuple = [string, string?];

// @public (undocumented)
export type RemirrorActions<GKeys extends string = string> = Record<GKeys, ActionMethods>;

// @public
export type RemirrorContentType = string | ObjectNode | ProsemirrorNode;

// Warning: (ae-forgotten-export) The symbol "RemoveMarkParams" needs to be exported by the entry point index.d.ts
//
// @public
export const removeMark: ({ type, expand }: RemoveMarkParams) => CommandFunction;

// @public
export const removeNodeAtPos: (position: number) => (tr: import("prosemirror-state").Transaction<import("prosemirror-model").Schema<string, string>>) => import("prosemirror-state").Transaction<import("prosemirror-model").Schema<string, string>>;

// @public
export const removeNodeBefore: (tr: import("prosemirror-state").Transaction<import("prosemirror-model").Schema<string, string>>) => import("prosemirror-state").Transaction<import("prosemirror-model").Schema<string, string>>;

// Warning: (ae-forgotten-export) The symbol "ReplaceTextParams" needs to be exported by the entry point index.d.ts
//
// @public
export const replaceText: ({ from, to, type, attrs, appendText, content, }: ReplaceTextParams) => CommandFunction;

// @alpha
export interface RequiredExtension {
    // (undocumented)
    extension: AnyExtension;
    // (undocumented)
    options: any;
}

// @public (undocumented)
export type ResolvedPos = ResolvedPos_2<EditorSchema>;

// @public (undocumented)
export type SchemaMarkTypeParams = SchemaTypeParams<MarkType_2<EditorSchema>>;

// @public (undocumented)
export type SchemaNodeTypeParams = SchemaTypeParams<NodeType_2<EditorSchema>>;

// @public (undocumented)
export interface SchemaParams {
    schema: EditorSchema;
}

// Warning: (ae-forgotten-export) The symbol "InferredType" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type SchemaTypeParams<GType> = ExtensionManagerParams & InferredType<GType>;

// @public (undocumented)
export type Selection = Selection_2<EditorSchema>;

// @public
export const selectionEmpty: (value: Selection_2<import("prosemirror-model").Schema<string, string>> | import("prosemirror-state").EditorState<import("prosemirror-model").Schema<string, string>>) => boolean;

// @public
export const setPluginMeta: <GMeta>(key: string | Plugin_2<any, any> | import("prosemirror-state").PluginKey<any, import("prosemirror-model").Schema<string, string>>, tr: import("prosemirror-state").Transaction<import("prosemirror-model").Schema<string, string>>, data: GMeta) => import("prosemirror-state").Transaction<import("prosemirror-model").Schema<string, string>>;

// @public
export enum Side {
    // (undocumented)
    LEFT = "left",
    // (undocumented)
    RIGHT = "right"
}

// @public
export function startCase(str: string): string;

// @public
export function startPositionOfParent(pmPosition: ResolvedPos): number;

// @public
export const take: <GArray extends any[]>(arr: GArray, num: number) => any[];

// @public (undocumented)
export class Text extends NodeExtension {
    // (undocumented)
    readonly name: "text";
    // (undocumented)
    readonly schema: {
        group: string;
    };
}

// Warning: (ae-forgotten-export) The symbol "FromNodeParams" needs to be exported by the entry point index.d.ts
//
// @public
export const toDOM: ({ node, schema, doc }: FromNodeParams) => DocumentFragment;

// Warning: (ae-forgotten-export) The symbol "ToggleBlockItemParams" needs to be exported by the entry point index.d.ts
//
// @public
export const toggleBlockItem: ({ type, toggleType, attrs }: ToggleBlockItemParams) => CommandFunction;

// @public
export const toggleList: (type: NodeType_2<any>, itemType: NodeType_2<any>) => CommandFunction;

// @public
export const toggleWrap: (type: NodeType_2<any>, attrs?: Record<string, string | number | undefined> | undefined) => CommandFunction;

// @public
export const toHTML: ({ node, schema, doc }: FromNodeParams) => string;

// @public (undocumented)
export type Transaction = Transaction_2<EditorSchema>;

// Warning: (ae-internal-missing-underscore) The name transformExtensionMap should be prefixed with an underscore because the declaration is marked as "@internal"
//
// @internal
export const transformExtensionMap: (extensionMapValues: ExtensionMapValue[]) => Extension<any, any, string>[];

// @public
export const trim: (str: string) => string;

// @public
export const uniqueArray: <GType>(array: GType[]) => GType[];

// Warning: (ae-forgotten-export) The symbol "UniqueIdParams" needs to be exported by the entry point index.d.ts
//
// @public
export const uniqueId: ({ prefix, size }?: UniqueIdParams) => string;

// @public
export const updateMark: (type: MarkType_2<any>, attrs?: Record<string, string | number | undefined>) => CommandFunction;

// @public (undocumented)
export type Value<GRecord> = GRecord[Key<GRecord>];

// @public
export const ZERO_WIDTH_SPACE_CHAR = "\u200B";


// (No @packageDocumentation comment for this package)

```
